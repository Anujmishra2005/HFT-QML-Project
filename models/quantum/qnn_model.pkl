import pennylane as qml
from pennylane import numpy as np
import joblib
import os

MODEL_PATH = "models/quantum/qnn_model.pkl"

dev = qml.device("default.qubit", wires=4)

def qnn_layer(weights):
    qml.StronglyEntanglingLayers(weights, wires=range(4))

@qml.qnode(dev)
def qnn_circuit(weights, x=None):
    for i in range(len(x)):
        qml.RX(x[i], wires=i)
    qnn_layer(weights)
    return qml.expval(qml.PauliZ(0))

def qnn_predict(weights, X):
    preds = []
    for x in X:
        val = qnn_circuit(weights, x)
        preds.append(1 if val > 0 else -1)
    return np.array(preds)

def train_qnn(X, y, steps=50, lr=0.1):
    weights = np.random.normal(0, np.pi, (1, 4, 3), requires_grad=True)
    opt = qml.AdamOptimizer(lr)

    def cost(weights):
        preds = [qnn_circuit(weights, x) for x in X]
        loss = np.mean((preds - y) ** 2)
        return loss

    for i in range(steps):
        weights, curr_cost = opt.step_and_cost(cost, weights)
        if i % 10 == 0:
            print(f"Step {i}: cost={curr_cost:.4f}")

    os.makedirs("models/quantum", exist_ok=True)
    joblib.dump(weights, MODEL_PATH)
    print(f"QNN model saved at {MODEL_PATH}")
    return weights

def load_qnn():
    if not os.path.exists(MODEL_PATH):
        raise FileNotFoundError(f"{MODEL_PATH} not found, train model first.")
    weights = joblib.load(MODEL_PATH)
    return weights
